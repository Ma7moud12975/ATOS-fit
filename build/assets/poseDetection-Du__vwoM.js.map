{"version":3,"file":"poseDetection-Du__vwoM.js","sources":["../../src/utils/poseDetection.js"],"sourcesContent":["// Pose detection utilities using MediaPipe\nclass PoseDetectionUtils {\n  constructor() {\n    this.pose = null;\n    this.isInitialized = false;\n  // Per-exercise state to avoid cross-contamination between different exercises\n  // Structure: { <mode>: { state: 'up'|'down'|'neutral'|..., count: number, extra... } }\n  this.perModeState = {};\n  const initMode = (mode) => ({ state: 'up', count: 0 });\n  this.perModeState['pushups'] = initMode('pushups');\n  this.perModeState['squats'] = initMode('squats');\n  this.perModeState['lunges'] = initMode('lunges');\n  this.perModeState['burpees'] = initMode('burpees');\n  this.perModeState['situps'] = { state: 'neutral', count: 0, _lastTorsoAngle: null, _situpState: 'neutral', _lastSitupTime: 0 };\n  this.perModeState['highknees'] = { state: 'down', count: 0 };\n  this.perModeState['jumpingjacks'] = { state: 'down', count: 0 };\n  this.perModeState['sideplank'] = { state: 'neutral', count: 0, _stableCount: 0, _lastHipY: null, _lastShoulderY: null, _lastAnkleY: null, _lastTimestamp: 0 };\n  this.perModeState['plank'] = { state: 'neutral', count: 0, _stableCount: 0, _lastHipY: null, _lastShoulderY: null, _lastAnkleY: null, _lastTimestamp: 0 };\n    this.postureStatus = 'unknown'; // correct, incorrect, unknown\n    this.lastWarningTime = 0;\n    this.videoDimensionsLogged = false;\n    // Exercise mode and timing\n    this.exerciseMode = 'pushups'; // 'pushups' | 'plank' | 'squats' | 'lunges'\n    this.accumulatedCorrectMs = 0;\n    this.timerRunning = false;\n    this.startCorrectTimestampMs = 0;\n    this.onPushupCount = null;\n    this.onPostureChange = null;\n    this.onFormFeedback = null;\n    this.onTimeUpdate = null; // for plank seconds updates\n  }\n\n  setExerciseMode(mode) {\n    // ensure perModeState exists for the selected mode\n    if (!this.perModeState[this.exerciseMode]) {\n      this.perModeState[this.exerciseMode] = { state: 'up', count: 0 };\n    }\n    const normalized = String(mode || '').toLowerCase();\n    if (normalized === 'plank') this.exerciseMode = 'plank';\n    else if (normalized === 'squats' || normalized === 'squat') this.exerciseMode = 'squats';\n    else if (normalized === 'lunges' || normalized === 'lunge') this.exerciseMode = 'lunges';\n    else if (normalized === 'burpees' || normalized === 'burpee') this.exerciseMode = 'burpees';\n  else if (normalized.includes('sit') || normalized.includes('situp') || normalized.includes('sit-ups') || normalized.includes('sit ups')) this.exerciseMode = 'situps';\n    else if (normalized.includes('high') && normalized.includes('knees')) this.exerciseMode = 'highknees';\n    else if (normalized.includes('jumping') && normalized.includes('jack')) this.exerciseMode = 'jumpingjacks';\n    else if (normalized.includes('side') && normalized.includes('plank')) this.exerciseMode = 'sideplank';\n    else this.exerciseMode = 'pushups';\n  }\n\n  // Initialize MediaPipe Pose\n  async initialize() {\n    try {\n      console.log('üöÄ Initializing MediaPipe Pose...');\n      \n      // Wait for MediaPipe to load if not ready\n      if (!window.Pose) {\n        console.warn('MediaPipe Pose not loaded yet, waiting...');\n        // Wait up to 10 seconds for MediaPipe to load\n        let attempts = 0;\n        while (!window.Pose && attempts < 50) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n          attempts++;\n          if (attempts % 10 === 0) {\n            console.log(`Still waiting for MediaPipe... (${attempts * 200}ms)`);\n          }\n        }\n        \n        if (!window.Pose) {\n          console.error('MediaPipe Pose failed to load after waiting');\n          return false;\n        }\n      }\n      \n      console.log('‚úÖ MediaPipe Pose found in window object');\n\n      this.pose = new window.Pose({\n        locateFile: (file) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n        }\n      });\n\n      const config = window.MediaPipeConfig?.POSE_CONFIG || {\n        modelComplexity: 0,\n        smoothLandmarks: true,\n        enableSegmentation: false,\n        smoothSegmentation: false,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      };\n\n      this.pose.setOptions(config);\n      this.pose.onResults(this.onResults.bind(this));\n      \n      this.isInitialized = true;\n      console.log('MediaPipe Pose initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('Failed to initialize MediaPipe Pose:', error);\n      return false;\n    }\n  }\n\n  // Process video frame\n  async processFrame(videoElement) {\n    if (!this.isInitialized || !this.pose) {\n      console.log('‚ùå Pose not initialized or missing');\n      return null;\n    }\n\n    try {\n      // Only log occasionally to avoid spam\n      if (Math.random() < 0.05) {\n        console.log('üìπ Processing frame...');\n      }\n      \n      // Check if video dimensions are reasonable\n      if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {\n        if (Math.random() < 0.1) {\n          console.log('‚è≥ Video dimensions not ready yet');\n        }\n        return;\n      }\n      \n      // Log video dimensions only once per session\n      if (!this.videoDimensionsLogged) {\n        console.log(`üìè Video dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);\n        this.videoDimensionsLogged = true;\n      }\n      \n      // Allow larger videos but with a reasonable limit\n      const maxWidth = 1920;\n      const maxHeight = 1080;\n      if (videoElement.videoWidth > maxWidth || videoElement.videoHeight > maxHeight) {\n        console.log('‚ö†Ô∏è Video too large (>1920x1080), skipping frame');\n        return;\n      }\n      \n      await this.pose.send({ image: videoElement });\n    } catch (error) {\n      if (error.message?.includes('memory access out of bounds')) {\n        console.warn('üîÑ Memory error, skipping frame');\n        return;\n      }\n      console.error('Error processing frame:', error);\n    }\n  }\n\n  // Handle pose detection results\n  onResults(results) {\n    console.log('üéØ onResults called!', results.poseLandmarks ? `Found ${results.poseLandmarks.length} landmarks` : 'No landmarks');\n    \n    // Store results for drawing\n    this.lastResults = results;\n    \n    if (!results.poseLandmarks) {\n      this.postureStatus = 'unknown';\n      if (this.onPostureChange) {\n        this.onPostureChange('unknown', null);\n      }\n      // Stop plank timer if running\n      if (this.timerRunning) {\n        this.accumulatedCorrectMs += Date.now() - this.startCorrectTimestampMs;\n        this.timerRunning = false;\n        this.startCorrectTimestampMs = 0;\n        if (this.onTimeUpdate) {\n          this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n        }\n      }\n      return;\n    }\n\n    const landmarks = results.poseLandmarks;\n    \n    // Evaluate posture for the current exercise using the unified checker.\n    // Use a short consecutive-frame smoothing window to avoid brief spikes flipping posture state\n    const isPostureCorrectInstant = this.checkBackAlignment(landmarks);\n\n    // Initialize counters if missing\n    if (this._postureGoodCount == null) this._postureGoodCount = 0;\n    if (this._postureBadCount == null) this._postureBadCount = 0;\n\n    if (isPostureCorrectInstant) {\n      this._postureGoodCount += 1;\n      this._postureBadCount = 0;\n    } else {\n      this._postureBadCount += 1;\n      this._postureGoodCount = 0;\n    }\n\n  const POSTURE_GOOD_FRAMES = window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_GOOD_FRAMES ?? 3;\n  // For squats we require more consecutive bad frames before flipping to 'incorrect' to avoid\n  // false positives during normal descent. Default to 6 for squats, 4 otherwise.\n  const POSTURE_BAD_FRAMES = (this.exerciseMode === 'squats') ? (window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_BAD_FRAMES ?? 6) : (window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_BAD_FRAMES ?? 4);\n\n    let smoothedStatus = this.postureStatus;\n    if (this._postureGoodCount >= POSTURE_GOOD_FRAMES) {\n      smoothedStatus = 'correct';\n    } else if (this._postureBadCount >= POSTURE_BAD_FRAMES) {\n      smoothedStatus = 'incorrect';\n    }\n\n    // For squats we don't want to show poor/incorrect posture feedback ‚Äî treat as correct.\n    if (this.exerciseMode === 'squats') {\n      smoothedStatus = 'correct';\n    }\n\n    if (smoothedStatus !== this.postureStatus) {\n      this.postureStatus = smoothedStatus;\n      if (this.onPostureChange) this.onPostureChange(this.postureStatus, landmarks);\n    }\n\n    // If posture is incorrect for strength/technique exercises, warn and normally skip counting.\n    // However, allow deep squat descents (hip below knee) to proceed to the squat counter so\n    // counting can occur if legs are stable. The squat counter itself still enforces stability\n    // and collapse checks.\n  const cardioExercises = ['highknees'];\n\n    // Compute hip/knee centers to detect a deep squat descent (hip below knee)\n    const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n    const leftHip = landmarks[cfg.LEFT_HIP || 23];\n    const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n    const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n    const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n    const hipCenter = leftHip && rightHip ? { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 } : null;\n    const kneeCenter = leftKnee && rightKnee ? { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 } : null;\n    const hipBelowKnee = hipCenter && kneeCenter ? (hipCenter.y > kneeCenter.y) : false;\n\n  // Do not emit posture warnings or block counting for squats; allow squat-specific logic to handle counting.\n  if (this.postureStatus !== 'correct' && !cardioExercises.includes(this.exerciseMode) && this.exerciseMode !== 'squats') {\n      const currentTime = Date.now();\n      const cooldown = window.MediaPipeConfig?.PLANK_CONFIG?.WARNING_COOLDOWN || 2000;\n\n      if (currentTime - this.lastWarningTime > cooldown) {\n        this.playWarningSound();\n        this.lastWarningTime = currentTime;\n\n        if (this.onFormFeedback) {\n          this.onFormFeedback({\n            message: \"Dangerous posture - straighten your back!\",\n            type: \"warning\",\n            timestamp: currentTime\n          });\n        }\n      }\n\n      // Stop plank timer while incorrect\n      if ((this.exerciseMode === 'plank' || this.exerciseMode === 'sideplank') && this.timerRunning) {\n        this.accumulatedCorrectMs += currentTime - this.startCorrectTimestampMs;\n        this.timerRunning = false;\n        this.startCorrectTimestampMs = 0;\n        if (this.onTimeUpdate) {\n          this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n        }\n      }\n\n      // Do not proceed to rep counting when posture is incorrect for non-cardio exercises\n      return;\n    }\n\n    // Posture is correct\n    if (this.exerciseMode === 'plank' || this.exerciseMode === 'sideplank') {\n      // For plank we require a stricter horizontal+stability check before counting time.\n      const now = Date.now();\n      const plankOk = this.isPlankStrictAndStable(landmarks, now);\n\n      if (plankOk) {\n        if (!this.timerRunning) {\n          this.startCorrectTimestampMs = now;\n          this.timerRunning = true;\n        }\n        const totalMs = this.accumulatedCorrectMs + (now - (this.startCorrectTimestampMs || now));\n        const seconds = Math.floor(totalMs / 1000);\n        if (this.onTimeUpdate) this.onTimeUpdate(seconds);\n      } else {\n        // Stop timer if it was running\n        if (this.timerRunning) {\n          this.accumulatedCorrectMs += now - this.startCorrectTimestampMs;\n          this.timerRunning = false;\n          this.startCorrectTimestampMs = 0;\n          if (this.onTimeUpdate) {\n            this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n          }\n        }\n      }\n\n      return;\n    }\n\n    // Count reps depending on mode\n      if (this.exerciseMode === 'squats') {\n        this.updateSquatCounter(landmarks);\n      } else if (this.exerciseMode === 'lunges') {\n        this.updateLungesCounter(landmarks);\n      } else if (this.exerciseMode === 'burpees') {\n        this.updateBurpeesCounter(landmarks);\n      } else if (this.exerciseMode === 'situps') {\n        this.updateSitUpsCounter(landmarks);\n      } else if (this.exerciseMode === 'highknees') {\n        this.updateHighKneesCounter(landmarks);\n      } else if (this.exerciseMode === 'jumpingjacks') {\n        this.updateJumpingJacksCounter(landmarks);\n      } else if (this.exerciseMode === 'sideplank') {\n        this.updateSidePlankCounter(landmarks);\n      } else {\n        this.updatePushupCounter(landmarks);\n      }\n  }\n\n  // Calculate angle between three points\n  calculateAngle(point1, point2, point3) {\n    const radians = Math.atan2(point3.y - point2.y, point3.x - point2.x) - \n                   Math.atan2(point1.y - point2.y, point1.x - point2.x);\n    let angle = Math.abs(radians * 180.0 / Math.PI);\n    \n    if (angle > 180.0) {\n      angle = 360 - angle;\n    }\n    \n    return angle;\n  }\n\n  // Strict plank check: require near-horizontal torso and low movement across consecutive frames\n  isPlankStrictAndStable(landmarks, nowMs) {\n    try {\n      const cfg = window.MediaPipeConfig?.PLANK_CONFIG || {};\n      const LEFT_SHOULDER = cfg.LEFT_SHOULDER || 11;\n      const RIGHT_SHOULDER = cfg.RIGHT_SHOULDER || 12;\n      const LEFT_HIP = cfg.LEFT_HIP || 23;\n      const RIGHT_HIP = cfg.RIGHT_HIP || 24;\n      const LEFT_ANKLE = cfg.LEFT_ANKLE || 27;\n      const RIGHT_ANKLE = cfg.RIGHT_ANKLE || 28;\n\n      const leftShoulder = landmarks[LEFT_SHOULDER];\n      const rightShoulder = landmarks[RIGHT_SHOULDER];\n      const leftHip = landmarks[LEFT_HIP];\n      const rightHip = landmarks[RIGHT_HIP];\n      const leftAnkle = landmarks[LEFT_ANKLE];\n      const rightAnkle = landmarks[RIGHT_ANKLE];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      // Require at least shoulders and hips on one side or both for reliable horizontal check\n      const leftSideOk = vis(leftShoulder) && vis(leftHip);\n      const rightSideOk = vis(rightShoulder) && vis(rightHip);\n      if (!leftSideOk && !rightSideOk) return false;\n\n      // Compute torso horizontal orientation (prefer side-view angle when available)\n      let horizontalOk = false;\n  const MIN_SIDE_ANGLE = cfg.MIN_SIDE_ANGLE ?? 155; // degrees\n      if (vis(leftShoulder) && vis(leftHip) && vis(leftAnkle)) {\n        const sideAngle = this.calculateAngle(leftShoulder, leftHip, leftAnkle);\n        horizontalOk = sideAngle >= MIN_SIDE_ANGLE;\n      } else if (vis(rightShoulder) && vis(rightHip) && vis(rightAnkle)) {\n        const sideAngle = this.calculateAngle(rightShoulder, rightHip, rightAnkle);\n        horizontalOk = sideAngle >= MIN_SIDE_ANGLE;\n      } else {\n        // front-facing fallback: shoulder-hip axis near horizontal\n  const shoulderCenter = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n  const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n  const dx = shoulderCenter.x - hipCenter.x;\n  const dy = shoulderCenter.y - hipCenter.y;\n  const orientDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n  // Allow slightly more tolerance for imperfect camera angles / small movements\n  const HORIZ_MAX = cfg.HORIZ_MAX_DEG ?? 30;\n  horizontalOk = (orientDeg <= HORIZ_MAX) || (orientDeg >= (180 - HORIZ_MAX));\n      }\n\n      if (!horizontalOk) return false;\n\n      // Stability: ensure minimal movement in key points across consecutive frames\n  // Use per-mode state so sideplank and plank maintain independent stability counters\n  const state = this.perModeState[this.exerciseMode] || this.perModeState['plank'];\n      const hipY = (leftHip.y + rightHip.y) / 2;\n      const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n      const ankleY = (leftAnkle && rightAnkle) ? ((leftAnkle.y + rightAnkle.y) / 2) : null;\n\n  // Allow more movement per second (user may sway slightly) ‚Äî increase default tolerance\n  const maxDeltaPerSec = cfg.MAX_DELTA_PER_SEC ?? 0.25; // normalized units per second\n      const now = nowMs || Date.now();\n      const dt = Math.max(1, now - (state._lastTimestamp || now));\n\n      let hipDelta = state._lastHipY == null ? 0 : Math.abs(hipY - state._lastHipY);\n      let shoulderDelta = state._lastShoulderY == null ? 0 : Math.abs(shoulderY - state._lastShoulderY);\n      let ankleDelta = (ankleY == null || state._lastAnkleY == null) ? 0 : Math.abs(ankleY - state._lastAnkleY);\n\n      // Normalize deltas to per-second rates\n      const hipRate = hipDelta * (1000 / dt);\n      const shoulderRate = shoulderDelta * (1000 / dt);\n      const ankleRate = ankleDelta * (1000 / dt);\n\n      const motionTooHigh = (hipRate > maxDeltaPerSec) || (shoulderRate > maxDeltaPerSec) || (ankleY != null && ankleRate > maxDeltaPerSec);\n\n      if (!motionTooHigh) {\n        state._stableCount = (state._stableCount || 0) + 1;\n      } else {\n        state._stableCount = 0;\n      }\n\n      // Update last positions and timestamp for next frame\n      state._lastHipY = hipY;\n      state._lastShoulderY = shoulderY;\n      if (ankleY != null) state._lastAnkleY = ankleY;\n      state._lastTimestamp = now;\n\n  // Require fewer consecutive 'stable' frames so small adjustments don't block counting\n  const REQUIRED_STABLE_FRAMES = cfg.REQUIRED_STABLE_FRAMES ?? 4;\n      const stableEnough = state._stableCount >= REQUIRED_STABLE_FRAMES;\n\n      // Additionally enforce that user is not upright (filter out standing or knee-supported poses)\n      // Use hip vs ankle vertical gap when ankles visible\n      if (ankleY != null) {\n        const hipAnkleDy = Math.abs(hipY - ankleY);\n        // Reduce required hip-ankle gap so cameras that crop feet or users on soft surfaces still count\n        const MIN_HIP_ANKLE_DY = cfg.MIN_HIP_ANKLE_DY ?? 0.06;\n        if (hipAnkleDy < MIN_HIP_ANKLE_DY) return false;\n      }\n\n      return stableEnough;\n    } catch (e) {\n      console.error('isPlankStrictAndStable error', e);\n      return false;\n    }\n  }\n\n  // Detect stable push-up start pose: torso roughly horizontal and ankles visible (proxy for being on toes)\n  isPushupStartPose(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftAnkle) || !vis(rightAnkle)) {\n        return false;\n      }\n\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const hipCenterY = (leftHip.y + rightHip.y) / 2;\n\n      // torso vertical difference small -> near horizontal\n      const torsoDy = Math.abs(shoulderCenterY - hipCenterY);\n      const THRESH = window.MediaPipeConfig?.PUSHUP_CONFIG?.START_TORSO_DY ?? 0.08;\n      if (torsoDy > THRESH) return false;\n\n      // ankles visible and reasonably below hips (on toes) as an extra proxy\n      const ankleBelowHip = ((leftAnkle.y + rightAnkle.y) / 2) > hipCenterY;\n      if (!ankleBelowHip) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Detect stable squat start pose: standing upright with hips above knees and torso approximately vertical\n  isSquatStartPose(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      // Require shoulders, hips and knees for a reliable standing start pose.\n      // Ankles are optional because many webcams/cameras crop the feet.\n      if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftKnee) || !vis(rightKnee)) {\n        return false;\n      }\n\n      const hipY = (leftHip.y + rightHip.y) / 2;\n      const kneeY = (leftKnee.y + rightKnee.y) / 2;\n      // In normalized coordinates hip above knee when standing\n      const gap = kneeY - hipY; // positive when hip above knee\n  const GAP_MIN = window.MediaPipeConfig?.SQUAT_CONFIG?.START_HIP_KNEE_GAP ?? 0.01;\n      if (gap < GAP_MIN) return false;\n\n      // Torso should be roughly vertical when standing\n      const shoulderCenter = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n      const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const dx = shoulderCenter.x - hipCenter.x;\n      const dy = shoulderCenter.y - hipCenter.y;\n      const angDeg = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI); // similar to torso tilt in squat logic\n  const MIN_VERT = window.MediaPipeConfig?.SQUAT_CONFIG?.STANDING_TORSO_MIN_DEG ?? 60;\n  const MAX_VERT = window.MediaPipeConfig?.SQUAT_CONFIG?.STANDING_TORSO_MAX_DEG ?? 120;\n      if (angDeg < MIN_VERT || angDeg > MAX_VERT) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Check back alignment for posture\n  checkBackAlignment(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      \n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      // Require visibility. For plank allow side-view (one side) visibility; for other exercises require both sides for stability.\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      if (this.exerciseMode === 'plank') {\n        const leftSideOk = vis(leftShoulder) && vis(leftHip);\n        const rightSideOk = vis(rightShoulder) && vis(rightHip);\n        if (!leftSideOk && !rightSideOk) {\n          // Not enough landmarks to evaluate plank reliably\n          return false;\n        }\n      } else if (this.exerciseMode === 'pushups') {\n        // For push-ups we only require both shoulders and hips to be visible.\n        if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip)) {\n          return false;\n        }\n      } else {\n        // For other exercises require knees visible for stability\n        if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftKnee) || !vis(rightKnee)) {\n          return false;\n        }\n      }\n\n      // Calculate center points\n      const shoulderCenter = {\n        x: (leftShoulder.x + rightShoulder.x) / 2,\n        y: (leftShoulder.y + rightShoulder.y) / 2\n      };\n      \n      const hipCenter = {\n        x: (leftHip.x + rightHip.x) / 2,\n        y: (leftHip.y + rightHip.y) / 2\n      };\n      \n      const kneeCenter = {\n        x: (leftKnee.x + rightKnee.x) / 2,\n        y: (leftKnee.y + rightKnee.y) / 2\n      };\n      const ankleCenter = (vis(leftAnkle) && vis(rightAnkle)) ? {\n        x: (leftAnkle.x + rightAnkle.x) / 2,\n        y: (leftAnkle.y + rightAnkle.y) / 2\n      } : null;\n\n      // Vectors for straightness\n      const targetPoint = ankleCenter || kneeCenter;\n      const v1 = { x: shoulderCenter.x - hipCenter.x, y: shoulderCenter.y - hipCenter.y };\n      const v2 = targetPoint ? { x: targetPoint.x - hipCenter.x, y: targetPoint.y - hipCenter.y } : null;\n\n      let isGoodPosture = false;\n      if (this.exerciseMode === 'plank') {\n        // Plank: support both front-facing and side-view evaluation.\n        const cfg = window.MediaPipeConfig?.PLANK_CONFIG || {};\n\n        // Prefer side-view detection when one full side is visible (shoulder, hip, ankle)\n        const leftSideVisible = vis(leftShoulder) && vis(leftHip) && vis(leftAnkle);\n        const rightSideVisible = vis(rightShoulder) && vis(rightHip) && vis(rightAnkle);\n\n        if (leftSideVisible || rightSideVisible) {\n          const shoulder = leftSideVisible ? leftShoulder : rightShoulder;\n          const hip = leftSideVisible ? leftHip : rightHip;\n          const ankle = leftSideVisible ? leftAnkle : rightAnkle;\n\n          // Angle at hip between shoulder-hip-ankle: near 180¬∞ for a straight plank\n          const sideAngle = this.calculateAngle(shoulder, hip, ankle);\n          const minSideAngle = cfg.MIN_SIDE_ANGLE ?? 155; // degrees\n\n          isGoodPosture = sideAngle >= minSideAngle;\n\n          // optional knee check when both ankles visible\n          if (isGoodPosture && ankleCenter) {\n            const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n            const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n            const kneeMin = cfg.KNEE_MIN_DEG ?? 150;\n            const kneeOk = (leftKneeAngle >= kneeMin) && (rightKneeAngle >= kneeMin);\n            isGoodPosture = isGoodPosture && kneeOk;\n          }\n\n        } else {\n          // Fallback: use center-based straightness + orientation as before (front-facing)\n          let cosSim = -1;\n          if (v2) {\n            const mag1 = Math.hypot(v1.x, v1.y) || 1;\n            const mag2 = Math.hypot(v2.x, v2.y) || 1;\n            cosSim = (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2);\n          }\n          const absCos = Math.abs(Math.max(-1, Math.min(1, cosSim)));\n          const straightEnough = v2 ? (absCos >= (cfg.STRAIGHT_ABS_COS_MIN ?? 0.90)) : false;\n          const dx = shoulderCenter.x - hipCenter.x;\n          const dy = shoulderCenter.y - hipCenter.y;\n          const orientDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n          const horizMax = cfg.HORIZ_MAX_DEG ?? 35;\n          const nearHorizontal = (orientDeg <= horizMax) || (orientDeg >= (180 - horizMax));\n          let kneeOk = true;\n          if (ankleCenter) {\n            const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n            const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n            const kneeMin = cfg.KNEE_MIN_DEG ?? 150;\n            kneeOk = (leftKneeAngle >= kneeMin) && (rightKneeAngle >= kneeMin);\n          }\n          isGoodPosture = straightEnough && nearHorizontal && kneeOk;\n        }\n\n      } else if (this.exerciseMode === 'squats') {\n        // Squats: accept normal descent (hip moving below knee) as a valid posture.\n        // Only flag 'BAD' when there's severe hip/back collapse (rounded back).\n        const scfg = window.MediaPipeConfig?.SQUAT_CONFIG || {};\n        const hipAngleLeft = this.calculateAngle(leftShoulder, leftHip, leftKnee);\n        const hipAngleRight = this.calculateAngle(rightShoulder, rightHip, rightKnee);\n        const hipAngle = (hipAngleLeft + hipAngleRight) / 2;\n        // Configurable thresholds\n        const hipAngleMin = scfg.HIP_ANGLE_MIN ?? 120; // generous minimum for 'upright' expectation\n        const collapseThreshold = scfg.HIP_ANGLE_COLLAPSE ?? 60; // below this -> collapsed (bad)\n        const dx = shoulderCenter.x - hipCenter.x;\n        const dy = shoulderCenter.y - hipCenter.y;\n        const torsoTiltDeg = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI);\n        const tiltMax = scfg.TORSO_TILT_MAX ?? 60;\n\n        // Determine hip vs knee vertical relationship (allow descent)\n        const hipBelowKnee = kneeCenter && (hipCenter.y > kneeCenter.y);\n\n        const collapseTiltMin = scfg.COLLAPSE_TILT_MIN ?? 70; // require significant forward rounding\n        if (hipAngle < collapseThreshold && torsoTiltDeg > collapseTiltMin) {\n          // Severe collapse (rounded back + low hip angle) ‚Äî definitely bad\n          isGoodPosture = false;\n        } else if (hipBelowKnee) {\n          // Normal squat descent ‚Äî accept as good (as long as collapse not detected)\n          isGoodPosture = true;\n        } else {\n          // Standing/upright checks: require reasonable hip angle and torso tilt\n          isGoodPosture = (hipAngle >= hipAngleMin) && (torsoTiltDeg <= tiltMax);\n        }\n      } else {\n        // Push-ups: prefer a dedicated horizontal-body check.\n        // Two modes: side view (ankles visible) -> use straight-line similarity as before.\n        // Front/angled view (no ankle visibility) -> check shoulder-hip orientation close to horizontal\n        const cfg = window.MediaPipeConfig?.PUSHUP_CONFIG || {};\n        const SIDE_ABS_COS_MIN = cfg.SIDE_ABS_COS_MIN ?? 0.82; // slightly more lenient\n        const HORIZ_TORSO_MAX_DEG = cfg.HORIZ_TORSO_MAX_DEG ?? 35; // allow more tilt\n\n        // If ankle center available assume side/diagonal view and use cos similarity\n        if (ankleCenter && v2) {\n          let cosSim = -1;\n          const mag1 = Math.hypot(v1.x, v1.y) || 1;\n          const mag2 = Math.hypot(v2.x, v2.y) || 1;\n          cosSim = (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2);\n          const absCos = Math.abs(Math.max(-1, Math.min(1, cosSim)));\n          isGoodPosture = absCos >= SIDE_ABS_COS_MIN;\n        } else {\n          // Fallback: check that shoulder-hip axis is near horizontal (small dy)\n          const dx = shoulderCenter.x - hipCenter.x;\n          const dy = shoulderCenter.y - hipCenter.y;\n          const angDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n          // angle near 0 or near 180 -> horizontal\n          const nearHorizontal = (angDeg <= HORIZ_TORSO_MAX_DEG) || (angDeg >= (180 - HORIZ_TORSO_MAX_DEG));\n          // Also ensure it's not standing (i.e., torso nearly vertical)\n          const nearVertical = (angDeg >= 90 - 20 && angDeg <= 90 + 20);\n          isGoodPosture = nearHorizontal && !nearVertical;\n        }\n      }\n\n      console.log(`üèÉ Posture(${this.exerciseMode}): ${isGoodPosture ? 'GOOD' : 'BAD'}`);\n      \n      return isGoodPosture;\n    } catch (error) {\n      console.error('Error checking back alignment:', error);\n      return false;\n    }\n  }\n\n  // Update push-up counter\n  updatePushupCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const pushupConfig = window.MediaPipeConfig?.PUSHUP_CONFIG || {};\n      \n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n\n      if (!leftShoulder || !leftElbow || !leftWrist || !rightShoulder || !rightElbow || !rightWrist || !leftHip || !rightHip) {\n        return;\n      }\n\n      // Calculate elbow angles\n      const leftElbowAngle = this.calculateAngle(leftShoulder, leftElbow, leftWrist);\n      const rightElbowAngle = this.calculateAngle(rightShoulder, rightElbow, rightWrist);\n      const avgElbowAngle = (leftElbowAngle + rightElbowAngle) / 2;\n\n      // Average shoulder position (for height detection)\n      const avgShoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n\n      const downThreshold = pushupConfig.ELBOW_ANGLE_DOWN || 95;\n      const upThreshold = pushupConfig.ELBOW_ANGLE_UP || 155;\n      const shoulderHeightThreshold = pushupConfig.SHOULDER_HEIGHT_DOWN || 0.02;\n\n      // Push-up position: elbows bent OR shoulders close to ground\n      // Determine if user is likely standing: if shoulders are well above hips and torso vertical\n      const shoulderHipDy = Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2));\n      const torsoVerticalThreshold = pushupConfig.TORSO_VERTICAL_DY ?? 0.15; // if shoulders far above hips (normalized units)\n      const isLikelyStanding = shoulderHipDy < (pushupConfig.STANDING_DY_MIN ?? 0.05) ? false : ((leftShoulder.y + rightShoulder.y) / 2) < ((leftHip.y + rightHip.y) / 2) - (pushupConfig.STANDING_DY_MIN ?? 0.02);\n\n      // Baseline shoulder level (approx when 'up' state) ‚Äî store per-mode baseline\n      const pstate = this.perModeState['pushups'];\n      if (!pstate._baselineShoulderY) {\n        // initialize baseline to current shoulder Y when pose roughly horizontal\n        pstate._baselineShoulderY = avgShoulderY;\n      }\n\n      // If posture is not horizontal, don't update baseline; else slowly adapt baseline\n      if (Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2)) < 0.12) {\n        // adapt baseline slowly\n        pstate._baselineShoulderY = (pstate._baselineShoulderY * 0.95) + (avgShoulderY * 0.05);\n      }\n\n      // Push-up position: significant drop from baseline OR elbow angle threshold\n      const shoulderDrop = avgShoulderY - (pstate._baselineShoulderY || avgShoulderY);\n      const shoulderDropThreshold = pushupConfig.SHOULDER_DROP_THRESHOLD ?? 0.06; // normalized units\n      const pushupPosition = (avgElbowAngle <= downThreshold) || (shoulderDrop >= shoulderDropThreshold) || (avgShoulderY >= (1 - shoulderHeightThreshold));\n      \n      // Standing position: elbows straight and shoulders high (not horizontal)\n      const standingPosition = (avgElbowAngle >= upThreshold) && isLikelyStanding;\n\n      // In-position gating: require user to assume a stable push-up start pose before starting counting\n      if (!pstate._inPositionCount) pstate._inPositionCount = 0;\n      const inStart = this.isPushupStartPose(landmarks);\n      if (inStart) {\n        pstate._inPositionCount += 1;\n      } else {\n        pstate._inPositionCount = 0;\n      }\n\n      const REQUIRED_STABLE_FRAMES = window.MediaPipeConfig?.PUSHUP_CONFIG?.START_STABLE_FRAMES ?? 6; // ~6 frames\n      pstate._isInStartPose = pstate._inPositionCount >= REQUIRED_STABLE_FRAMES;\n\n      // Debounce reps: minimum ms between consecutive counts\n      const MIN_REP_MS = window.MediaPipeConfig?.PUSHUP_CONFIG?.MIN_REP_MS ?? 400;\n      if (!pstate._lastRepAt) pstate._lastRepAt = 0;\n      const now = Date.now();\n\n      // Only count if posture is correct and user is in start pose\n      if (this.postureStatus !== 'correct' || !pstate._isInStartPose) {\n        return; // do not count\n      }\n\n      if (pstate.state === 'up') {\n        if (pushupPosition && (now - pstate._lastRepAt) > MIN_REP_MS) {\n          pstate.state = 'down';\n          pstate.count += 1; // Count on descent\n          pstate._lastRepAt = now;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(pstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Push-up ${pstate.count}`, type: 'success', timestamp: now });\n          }\n        }\n      } else if (pstate.state === 'down') {\n        // return to up when standingPosition or full extension detected\n        if (standingPosition || (!pushupPosition && avgElbowAngle >= upThreshold)) {\n          pstate.state = 'up'; // Reset state for next rep\n        }\n      }\n    } catch (error) {\n      console.error('Error updating push-up counter:', error);\n    }\n  }\n\n  // Update squat counter\n  updateSquatCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const scfg = window.MediaPipeConfig?.SQUAT_CONFIG || {};\n\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle || !leftShoulder || !rightShoulder) return;\n\n      // Check if user is in horizontal position (like pushup) - show warning but DO NOT count if so\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const hipCenterY = (leftHip.y + rightHip.y) / 2;\n      const head = landmarks[cfg.NOSE || 0];\n      const torsoDy = Math.abs(shoulderCenterY - hipCenterY);\n      const HORIZONTAL_THRESHOLD = 0.08; // Same threshold as pushup detection\n      // Check if head is at same y level as hips (head down, body horizontal)\n      const headHipDy = Math.abs((head?.y ?? 0) - hipCenterY);\n      const HEAD_HIP_HORIZONTAL_THRESHOLD = 0.10; // If head and hip are close in y, likely horizontal\n      let isHorizontalLikePushup = false;\n      if (torsoDy <= HORIZONTAL_THRESHOLD && headHipDy <= HEAD_HIP_HORIZONTAL_THRESHOLD) {\n        isHorizontalLikePushup = true;\n        // Optional: show warning\n        if (this.onFormFeedback) {\n          this.onFormFeedback({ \n            message: 'Ÿàÿ∂ÿπ ÿßŸÑÿ¨ÿ≥ŸÖ ÿ£ŸÅŸÇŸäÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßŸÑÿπÿØ ÿ•ŸÑÿß ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ŸÉŸàÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠', \n            type: 'warning', \n            timestamp: Date.now() \n          });\n        }\n      }\n\n      // Check if hands are on the ground (like pushup)\n      const leftWrist = landmarks[cfg.LEFT_WRIST || 15];\n      const rightWrist = landmarks[cfg.RIGHT_WRIST || 16];\n      const leftFoot = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightFoot = landmarks[cfg.RIGHT_ANKLE || 28];\n      // Consider hands on ground if both wrists are at or below the level of the ankles (with small margin)\n      const HANDS_ON_GROUND_THRESHOLD = 0.07; // allow small margin\n      let handsOnGround = false;\n      if (leftWrist && rightWrist && leftFoot && rightFoot) {\n        const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n        const avgFootY = (leftFoot.y + rightFoot.y) / 2;\n        if (avgWristY >= avgFootY - HANDS_ON_GROUND_THRESHOLD) {\n          handsOnGround = true;\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: 'ÿßŸÑŸäÿØŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ÿ±ÿ∂ÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßŸÑÿπÿØ ÿ•ŸÑÿß ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ŸÉŸàÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠',\n              type: 'warning',\n              timestamp: Date.now()\n            });\n          }\n        }\n      }\n\n      // Average sides for stability\n      const hip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const knee = { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 };\n      const ankle = { x: (leftAnkle.x + rightAnkle.x) / 2, y: (leftAnkle.y + rightAnkle.y) / 2 };\n      const shoulder = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n\n      // Knee angle using hip-knee-ankle\n      const kneeAngleLeft = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const kneeAngleRight = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n      const avgKneeAngle = (kneeAngleLeft + kneeAngleRight) / 2;\n\n      // Check leg stability - both legs should be moving together (not one leg down)\n      const leftKneeY = leftKnee.y;\n      const rightKneeY = rightKnee.y;\n      const kneeHeightDiff = Math.abs(leftKneeY - rightKneeY);\n      const LEG_STABILITY_THRESHOLD = 0.05; // Maximum difference between left and right knee heights\n      \n      const legsStable = kneeHeightDiff <= LEG_STABILITY_THRESHOLD;\n      \n      // Check if knees are bending (squatting down)\n      const kneesBending = avgKneeAngle < 120; // Knees bent when angle is less than 120 degrees\n\n      // Count based on hip position (lower back points)\n      const hipY = hip.y; // Y position of hips (lower = deeper)\n      const kneeY = knee.y; // Y position of knees\n      \n      // Hip goes below knee level = deep squat\n      const hipBelowKnee = hipY > kneeY;\n      // Hip goes back up above knee level = standing\n      const hipAboveKnee = hipY < kneeY;\n      \n      // State machine: count when hip goes down below knee level (use per-mode state)\n      const stateObj = this.perModeState['squats'];\n\n      // Debug logging\n      console.log('üîç Squat Debug:', {\n        legsStable,\n        kneesBending,\n        avgKneeAngle,\n        kneeHeightDiff,\n        hipBelowKnee,\n        hipAboveKnee,\n        state: stateObj.state,\n        count: stateObj.count\n      });\n\n      // Simplified squat counting: count when hips go below knees with stable legs\n      const MIN_REP_MS = window.MediaPipeConfig?.SQUAT_CONFIG?.MIN_REP_MS ?? 500;\n      if (!stateObj._lastRepAt) stateObj._lastRepAt = 0;\n      const now = Date.now();\n\n      if (stateObj.state === 'up') {\n        // Count if hips go below knees and legs are stable, and NOT in horizontal position or hands on ground\n        if (hipBelowKnee && legsStable && !isHorizontalLikePushup && !handsOnGround && (now - stateObj._lastRepAt) > MIN_REP_MS) {\n          stateObj.state = 'down';\n          stateObj.count += 1;\n          stateObj._lastRepAt = now;\n          console.log('üéØ Squat counted! Count:', stateObj.count);\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(stateObj.count);\n        } else {\n          // Debug why counting didn't happen\n          if (!hipBelowKnee) {\n            console.log('‚ùå Not counting: Hips not below knees');\n          } else if (!legsStable) {\n            console.log('‚ùå Not counting: Legs not stable (one leg down)');\n          } else if (isHorizontalLikePushup) {\n            console.log('‚ùå Not counting: Body is horizontal like pushup');\n          } else if (handsOnGround) {\n            console.log('‚ùå Not counting: Hands are on the ground');\n          } else if ((now - stateObj._lastRepAt) <= MIN_REP_MS) {\n            console.log('‚ùå Not counting: Too soon since last rep');\n          }\n        }\n      } else if (stateObj.state === 'down') {\n        if (hipAboveKnee) {\n          stateObj.state = 'up';\n          console.log('‚¨ÜÔ∏è Squat state changed to UP');\n        }\n      }\n    } catch (error) {\n      console.error('Error updating squat counter:', error);\n    }\n  }\n\n  // Update lunges counter\n  updateLungesCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const lcfg = window.MediaPipeConfig?.LUNGES_CONFIG || {};\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n      \n      // Check if hands are on the ground (like pushup) - don't count lunges if hands on ground\n      const leftWrist = landmarks[cfg.LEFT_WRIST || 15];\n      const rightWrist = landmarks[cfg.RIGHT_WRIST || 16];\n      const leftFoot = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightFoot = landmarks[cfg.RIGHT_ANKLE || 28];\n      const HANDS_ON_GROUND_THRESHOLD = 0.07;\n      let handsOnGround = false;\n      if (leftWrist && rightWrist && leftFoot && rightFoot) {\n        const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n        const avgFootY = (leftFoot.y + rightFoot.y) / 2;\n        if (avgWristY >= avgFootY - HANDS_ON_GROUND_THRESHOLD) {\n          handsOnGround = true;\n        }\n      }\n      \n      // Average hip position\n      const hip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      // Calculate knee angles\n      const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n      // Determine which leg is front (more bent knee) - allow both legs to be counted\n      const leftKneeBent = leftKneeAngle < rightKneeAngle;\n      const frontKnee = leftKneeBent ? leftKnee : rightKnee;\n      const backKnee = leftKneeBent ? rightKnee : leftKnee;\n      const frontKneeAngle = leftKneeBent ? leftKneeAngle : rightKneeAngle;\n      const backKneeAngle = leftKneeBent ? rightKneeAngle : leftKneeAngle;\n      \n      // Also check the opposite leg position (for alternating lunges)\n      const rightKneeBent = rightKneeAngle < leftKneeAngle;\n      const altFrontKnee = rightKneeBent ? rightKnee : leftKnee;\n      const altBackKnee = rightKneeBent ? leftKnee : rightKnee;\n      const altFrontKneeAngle = rightKneeBent ? rightKneeAngle : leftKneeAngle;\n      const altBackKneeAngle = rightKneeBent ? leftKneeAngle : rightKneeAngle;\n      // Hip position relative to front knee\n      const hipBelowFrontKnee = hip.y > frontKnee.y;\n      // Lunge position based on the image: one leg forward, body leaning forward, back knee close to ground\n      const KNEE_Y_DIFF_THRESHOLD = 0.06; // ŸÅÿ±ŸÇ Ÿàÿßÿ∂ÿ≠ ÿ®ŸäŸÜ ÿßŸÑÿ±ŸÉÿ®ÿ™ŸäŸÜ (ÿ±ÿ¨ŸÑ ŸÑŸÑÿ£ŸÖÿßŸÖ) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const BACK_KNEE_ANGLE_THRESHOLD = 120; // back knee bent (close to ground) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const FRONT_KNEE_ANGLE_THRESHOLD = 100; // front knee bent (stable support) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const HIP_FORWARD_THRESHOLD = 0.08; // hip leaning forward over front leg - ÿ™Ÿàÿ≥Ÿäÿπ\n      \n      const kneeYDiff = Math.abs(leftKnee.y - rightKnee.y);\n      const oneLegForward = kneeYDiff > KNEE_Y_DIFF_THRESHOLD;\n      \n      // Check first leg position (left leg forward)\n      const backKneeBent = backKneeAngle < BACK_KNEE_ANGLE_THRESHOLD;\n      const frontKneeBent = frontKneeAngle < FRONT_KNEE_ANGLE_THRESHOLD;\n      const frontHip = leftKneeBent ? leftHip : rightHip;\n      const frontAnkle = leftKneeBent ? leftAnkle : rightAnkle;\n      const hipForwardLean = Math.abs(frontHip.x - frontAnkle.x) < HIP_FORWARD_THRESHOLD;\n      const lungePosition1 = oneLegForward && backKneeBent && frontKneeBent && hipForwardLean;\n      \n      // Check second leg position (right leg forward)\n      const altBackKneeBent = altBackKneeAngle < BACK_KNEE_ANGLE_THRESHOLD;\n      const altFrontKneeBent = altFrontKneeAngle < FRONT_KNEE_ANGLE_THRESHOLD;\n      const altFrontHip = rightKneeBent ? rightHip : leftHip;\n      const altFrontAnkle = rightKneeBent ? rightAnkle : leftAnkle;\n      const altHipForwardLean = Math.abs(altFrontHip.x - altFrontAnkle.x) < HIP_FORWARD_THRESHOLD;\n      const lungePosition2 = oneLegForward && altBackKneeBent && altFrontKneeBent && altHipForwardLean;\n      \n      // Either leg position counts as a lunge\n      const lungePosition = lungePosition1 || lungePosition2;\n      // Standing position: both knees straight\n      const standingPosition = (frontKneeAngle >= 160) && (backKneeAngle >= 150);\n      // Simple counting: count immediately when going down (like squats)\n      const lstate = this.perModeState['lunges'];\n      if (lstate.state === 'up') {\n        if (!handsOnGround && lungePosition) {\n          lstate.state = 'down';\n          lstate.count += 1; // Count immediately on descent\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(lstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Lunge ${lstate.count}`, type: 'success', timestamp: Date.now() });\n          }\n        }\n      } else if (lstate.state === 'down') {\n        if (standingPosition) {\n          lstate.state = 'up'; // Reset state for next rep\n        }\n      }\n    } catch (error) {\n      console.error('Error updating lunges counter:', error);\n    }\n  }\n\n  // Update sit-ups counter\n  updateSitUpsCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n\n      if (!leftShoulder || !rightShoulder || !leftHip || !rightHip || !leftKnee || !rightKnee) return;\n\n      // Compute torso angle: shoulder - hip - knee (approximate sit-up bend)\n      const midShoulder = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n      const midHip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const midKnee = { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 };\n\n      const torsoAngle = this.calculateAngle(midShoulder, midHip, midKnee); // 180 = straight, lower = bent\n\n      const state = this.perModeState['situps'];\n      if (!state._lastTorsoAngle) state._lastTorsoAngle = torsoAngle;\n      if (!state._situpState) state._situpState = 'down';\n      if (!state._lastSitupTime) state._lastSitupTime = 0;\n\n      const now = Date.now();\n      const MIN_REP_MS = window.MediaPipeConfig?.SITUP_CONFIG?.MIN_REP_MS || 600;\n      const SITUP_ANGLE_DOWN = window.MediaPipeConfig?.SITUP_CONFIG?.ANGLE_DOWN ?? 120; // lying/back-resting ~ near 180\n      const SITUP_ANGLE_UP = window.MediaPipeConfig?.SITUP_CONFIG?.ANGLE_UP ?? 100; // when torso bends forward angle reduces\n\n      // We interpret a sit-up as torso angle moving from near-straight (down) to bent (up) and back\n      if (state._situpState === 'down') {\n        // waiting for upward movement (bending)\n        if (torsoAngle < SITUP_ANGLE_UP && (now - state._lastSitupTime) > MIN_REP_MS) {\n          state._situpState = 'up';\n          state._lastSitupTime = now;\n        }\n      } else if (state._situpState === 'up') {\n        // waiting to return to down to complete rep\n        if (torsoAngle > SITUP_ANGLE_DOWN && (now - state._lastSitupTime) > MIN_REP_MS) {\n          state._situpState = 'down';\n          state.count += 1;\n          state._lastSitupTime = now;\n          this.playSuccessSound();\n          if (this.onPushupCount) this.onPushupCount(state.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Sit-up ${state.count}`, type: 'success', timestamp: now });\n          }\n        }\n      }\n\n      // Update last angle\n      state._lastTorsoAngle = torsoAngle;\n\n      // Gentle posture feedback: if hips lift asymmetrically\n      if (Math.abs(leftHip.y - rightHip.y) > 0.08 && this.onFormFeedback && Math.random() < 0.08) {\n        this.onFormFeedback({ message: 'Keep hips level during sit-ups', type: 'warning', timestamp: now });\n      }\n\n    } catch (error) {\n      console.error('Error updating sit-ups counter:', error);\n    }\n  }\n\n  updateBurpeesCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      // ŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ£ÿ≥ ŸàÿßŸÑŸäÿØŸäŸÜ\n      const nose = landmarks[config.NOSE || 0];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftIndex = landmarks[config.LEFT_INDEX || 19];\n      const rightIndex = landmarks[config.RIGHT_INDEX || 20];\n      if (!nose || !leftWrist || !rightWrist) return;\n      // ÿ£ÿπŸÑŸâ ŸÜŸÇÿ∑ÿ© ŸÑŸÑÿ±ÿ£ÿ≥\n      const headY = nose.y;\n      // ÿ£ÿπŸÑŸâ ŸÜŸÇÿ∑ÿ© ŸÑŸÑŸäÿØ ÿ£Ÿà ÿßŸÑÿ£ÿµÿßÿ®ÿπ\n      const leftHandY = leftIndex ? leftIndex.y : leftWrist.y;\n      const rightHandY = rightIndex ? rightIndex.y : rightWrist.y;\n      // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸäÿØŸäŸÜ ÿ£Ÿà ÿßŸÑÿ£ÿµÿßÿ®ÿπ ÿ£ÿπŸÑŸâ ŸÖŸÜ ÿßŸÑÿ±ÿ£ÿ≥ (ÿ£ŸÇŸÑ ŸÅŸä ŸÇŸäŸÖÿ© y)\n      const handsAboveHead = (leftHandY < headY && rightHandY < headY);\n      // ŸÖŸÜÿ∑ŸÇ ÿßŸÑÿπÿØ\n      if (!this._burpeeState) this._burpeeState = 'ready';\n      if (!this.perModeState['burpees']._burpeeState) this.perModeState['burpees']._burpeeState = 'ready';\n      const bstate = this.perModeState['burpees'];\n      if (bstate._burpeeState === 'ready') {\n        if (handsAboveHead) {\n          bstate._burpeeState = 'jumping';\n          bstate.count += 1;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(bstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: `Burpee ${bstate.count} - Hands above head!`,\n              type: 'success',\n              timestamp: Date.now()\n            });\n          }\n        }\n      } else if (bstate._burpeeState === 'jumping') {\n        if (!handsAboveHead) {\n          bstate._burpeeState = 'ready';\n        }\n      }\n    } catch (error) {\n      console.error('Error updating burpees counter:', error);\n    }\n  }\n\n  updateHighKneesCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n\n      // Check if knee is at waist level or above (easier threshold)\n      const KNEE_HIP_THRESHOLD = 0.03; // Knee should be at waist level or above (easier)\n      const isLeftKneeHigh = (leftHip.y - leftKnee.y) > KNEE_HIP_THRESHOLD;\n      const isRightKneeHigh = (rightHip.y - rightKnee.y) > KNEE_HIP_THRESHOLD;\n\n      // Check if user is doing high knees movement (either leg up)\n      const isDoingHighKnees = isLeftKneeHigh || isRightKneeHigh;\n\n      // State machine for timing high knees (per-mode)\n      const hk = this.perModeState['highknees'];\n      if (!hk._highKneesState) hk._highKneesState = 'stopped';\n      if (!hk._startTime) hk._startTime = 0;\n      if (!hk._lastUpdateTime) hk._lastUpdateTime = 0;\n\n      const now = Date.now();\n      const MIN_MOVEMENT_INTERVAL = 100; // Minimum time between movements (ms)\n\n      if (hk._highKneesState === 'stopped') {\n        // Start timing when user begins high knees movement\n        if (isDoingHighKnees) {\n          hk._highKneesState = 'active';\n          hk._startTime = now;\n          hk._lastUpdateTime = now;\n          hk.count = 0; // Reset count\n          console.log('üèÉ High Knees started!');\n        }\n      } else if (hk._highKneesState === 'active') {\n        if (isDoingHighKnees) {\n          // Continue timing while user is doing high knees\n          hk._lastUpdateTime = now;\n          const elapsedSeconds = Math.floor((now - hk._startTime) / 1000);\n          \n          // Update count (in seconds) every second\n          if (elapsedSeconds > hk.count) {\n            hk.count = elapsedSeconds;\n            if (this.onPushupCount) this.onPushupCount(hk.count);\n            console.log(`‚è±Ô∏è High Knees: ${elapsedSeconds} seconds`);\n          }\n        } else {\n          // Check if user stopped for too long\n          const timeSinceLastMovement = now - hk._lastUpdateTime;\n          if (timeSinceLastMovement > 1500) { // Stop if no movement for 1.5 seconds\n            hk._highKneesState = 'stopped';\n            console.log('‚èπÔ∏è High Knees stopped!');\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating high knees counter:', error);\n    }\n  }\n\n  // Update jumping jacks counter\n updateJumpingJacksCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const jjConfig = window.MediaPipeConfig?.JUMPINGJACKS_CONFIG || {};\n\n      // Get key landmarks for jumping jacks\n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftShoulder || !rightShoulder || !leftHip || !rightHip || !leftKnee || !rightKnee || !leftElbow || !rightElbow || !leftWrist || !rightWrist || !leftAnkle || !rightAnkle) {\n        return;\n      }\n\n      // Calculate shoulder abduction angles (shoulder-elbow-wrist) - arms overhead\n      const leftShoulderAbduction = this.calculateAngle(leftElbow, leftShoulder, leftWrist);\n      const rightShoulderAbduction = this.calculateAngle(rightElbow, rightShoulder, rightWrist);\n\n      // Calculate hip abduction angles (hip-knee-ankle) - legs apart\n      const leftHipAbduction = this.calculateAngle(leftKnee, leftHip, leftAnkle);\n      const rightHipAbduction = this.calculateAngle(rightKnee, rightHip, rightAnkle);\n\n      // Calculate knee flexion angles (hip-knee-ankle)\n      const leftKneeFlexion = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const rightKneeFlexion = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n\n      // Stricter thresholds and robust UP->DOWN detection to match pose breakdown\n  const SHOULDER_ABDUCTION_DOWN = jjConfig.SHOULDER_ABDUCTION_DOWN || 40;\n  // slightly relaxed peak requirement for rotation tolerance\n  const SHOULDER_ABDUCTION_UP = jjConfig.SHOULDER_ABDUCTION_UP || 145;\n  const HIP_ABDUCTION_DOWN = jjConfig.HIP_ABDUCTION_DOWN || 12;\n  const HIP_ABDUCTION_UP = jjConfig.HIP_ABDUCTION_UP || 32;\n\n      // Timing and smoothing\n  const MIN_REP_MS = jjConfig.MIN_REP_MS || 800; // increase debounce to avoid double counts\n  const UP_FRAMES = jjConfig.UP_FRAMES || 2;\n  const DOWN_FRAMES = jjConfig.DOWN_FRAMES || 3; // require more stable down confirmation\n      const ANKLE_SCALE = jjConfig.ANKLE_SCALE || 1.1;\n      const MIN_UP_MS = jjConfig.MIN_UP_MS || 200; // require the peak (UP) to last at least this ms\n\n      const jjState = this.perModeState['jumpingjacks'];\n      if (!jjState._lastRepAt) jjState._lastRepAt = 0;\n      if (!jjState._upCount) jjState._upCount = 0;\n      if (!jjState._downCount) jjState._downCount = 0;\n      if (!jjState._baselineAnkleDist) jjState._baselineAnkleDist = null;\n      if (!jjState._upSince) jjState._upSince = 0;\n  // short running history to smooth noisy angle/distance jumps (rotation tolerant)\n  if (!jjState._history) jjState._history = [];\n  const HISTORY_MAX = jjConfig.HISTORY_MAX || 5;\n      const now = Date.now();\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n\n  // Angle and position measures (frame values)\n  const avgShoulderAbduction = (leftShoulderAbduction + rightShoulderAbduction) / 2;\n  const avgHipAbduction = (leftHipAbduction + rightHipAbduction) / 2;\n  const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n  const avgShoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n  const ankleDistance = Math.abs(leftAnkle.x - rightAnkle.x);\n  const hipDistance = Math.abs(leftHip.x - rightHip.x);\n\n  // Normalizers to make detection robust to camera tilt/zoom\n  // Use shoulder span (x-distance) and torso height (shoulder y to hip y) as stable measures\n  const shoulderSpan = Math.abs(leftShoulder.x - rightShoulder.x) || 0.0001;\n  const torsoHeight = Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2)) || 0.0001;\n  // normalized ankle distance relative to shoulder span (accounts for zoom/tilt)\n  const normalizedAnkleDistance = ankleDistance / shoulderSpan;\n  const normalizedHipDistance = hipDistance / shoulderSpan;\n  // normalized vertical wrist offset relative to torso height\n  const wristAboveShoulderNorm = ((avgShoulderY - avgWristY) / torsoHeight) || 0;\n\n  // Push latest measures into history and compute smoothed values\n  jjState._history.push({ sa: avgShoulderAbduction, ha: avgHipAbduction, nad: normalizedAnkleDistance, nhd: normalizedHipDistance, wan: wristAboveShoulderNorm });\n  if (jjState._history.length > HISTORY_MAX) jjState._history.shift();\n  const smooth = { sa: 0, ha: 0, nad: 0, nhd: 0, wan: 0 };\n  jjState._history.forEach(h => { smooth.sa += h.sa; smooth.ha += h.ha; smooth.nad += h.nad; smooth.nhd += h.nhd; smooth.wan += h.wan; });\n  const hf = jjState._history.length || 1;\n  const smoothedShoulderAbduction = smooth.sa / hf;\n  const smoothedHipAbduction = smooth.ha / hf;\n  const smoothedNormalizedAnkleDistance = smooth.nad / hf;\n  const smoothedNormalizedHipDistance = smooth.nhd / hf;\n  const smoothedWristAboveShoulder = smooth.wan / hf;\n\n      // Initialize baseline ankle distance when in DOWN and we have a stable reading\n      if (jjState.state === 'down' && (jjState._baselineAnkleDist == null) && ankleDistance > 0 && hipDistance > 0) {\n        jjState._baselineAnkleDist = Math.max(hipDistance, ankleDistance * 0.9);\n      }\n\n      // Precise checks for peak/UP position\n  // rotation/tilt tolerant checks\n  const wristsAboveHead = vis(leftWrist) && vis(rightWrist) && (wristAboveShoulderNorm > 0.18); // wrists sufficiently above shoulders relative to torso height\n  const anklesWider = normalizedAnkleDistance > Math.max((jjState._baselineAnkleDist ? (jjState._baselineAnkleDist / shoulderSpan) : normalizedHipDistance) * ANKLE_SCALE, normalizedHipDistance * ANKLE_SCALE);\n      const shouldersAngleUp = smoothedShoulderAbduction > SHOULDER_ABDUCTION_UP;\n      const hipsAngleApart = smoothedHipAbduction > HIP_ABDUCTION_UP;\n\n      // Consider UP if peak is well-formed: wrists above head and ankles wider OR strong angle indicators\n  // use smoothed/wrist-normalized checks for robustness to tilt\n  const wristsAboveHeadSm = vis(leftWrist) && vis(rightWrist) && (smoothedWristAboveShoulder > 0.16);\n  const anklesWiderSm = smoothedNormalizedAnkleDistance > Math.max((jjState._baselineAnkleDist ? (jjState._baselineAnkleDist / shoulderSpan) : smoothedNormalizedHipDistance) * ANKLE_SCALE, smoothedNormalizedHipDistance * ANKLE_SCALE);\n  const isUpPeak = (wristsAboveHeadSm && anklesWiderSm) || (shouldersAngleUp && hipsAngleApart) || (wristsAboveHeadSm && hipsAngleApart) || (shouldersAngleUp && anklesWiderSm);\n\n      // Consider DOWN if arms low and ankles near baseline\n  const armsLow = avgShoulderAbduction < SHOULDER_ABDUCTION_DOWN;\n  const anklesNarrow = smoothedNormalizedAnkleDistance < (((jjState._baselineAnkleDist || hipDistance) / shoulderSpan) * (ANKLE_SCALE - 0.05));\n  const isDownPose = (armsLow && anklesNarrow) || (smoothedShoulderAbduction < SHOULDER_ABDUCTION_DOWN && smoothedHipAbduction < HIP_ABDUCTION_DOWN);\n\n      // Debug info occasionally\n      if ((jjState._debugCounter || 0) % 30 === 0) {\n        jjState._debugCounter = 0;\n        console.log('üîç JJ Debug:', { avgShoulderAbduction: Math.round(avgShoulderAbduction), avgHipAbduction: Math.round(avgHipAbduction), wristsAboveHead, anklesWider, shouldersAngleUp, hipsAngleApart, state: jjState.state, count: jjState.count });\n      } else {\n        jjState._debugCounter = (jjState._debugCounter || 0) + 1;\n      }\n\n      // State transitions\n      // short ignore window after counting to avoid immediate re-detection from jitter\n      if (!jjState._ignoreUntil) jjState._ignoreUntil = 0;\n      if (jjState.state === 'down') {\n        if (isUpPeak) {\n          // only count UP frames if not in ignore window\n          if (now >= jjState._ignoreUntil) jjState._upCount += 1;\n          if (!jjState._upSince) jjState._upSince = now;\n        } else {\n          jjState._upCount = 0;\n          jjState._upSince = 0;\n        }\n\n        if (jjState._upCount >= UP_FRAMES && (now - (jjState._lastStateChange || 0)) > 120) {\n          jjState.state = 'up';\n          jjState._lastStateChange = now;\n          jjState._upCount = 0;\n          jjState._upSince = jjState._upSince || now;\n        }\n\n        // refresh baseline if idle\n        if ((now - (jjState._lastStateChange || 0)) > 6000) {\n          jjState._baselineAnkleDist = Math.max(hipDistance, ankleDistance * 0.9);\n        }\n\n      } else if (jjState.state === 'up') {\n        const upDuration = jjState._upSince ? (now - jjState._upSince) : 0;\n        if (isDownPose) {\n          jjState._downCount += 1;\n        } else {\n          jjState._downCount = 0;\n        }\n\n        // only count when coming back to DOWN (end of rep), ensure UP lasted minimum time and down is stable\n        if (jjState._downCount >= DOWN_FRAMES && upDuration >= MIN_UP_MS && (now - jjState._lastRepAt) > MIN_REP_MS) {\n          jjState.state = 'down';\n          jjState.count += 1;\n          jjState._lastRepAt = now;\n          jjState._lastStateChange = now;\n          jjState._downCount = 0;\n          jjState._upSince = 0;\n          // set a short ignore window proportional to MIN_REP_MS to avoid jitter-based double counts\n          jjState._ignoreUntil = now + Math.min(600, Math.floor(MIN_REP_MS / 2));\n          // recalibrate baseline relative to shoulder span\n          jjState._baselineAnkleDist = Math.max(hipDistance, ankleDistance * 0.9);\n          console.log('üéØ Jumping Jack counted (end-of-rep)! Count:', jjState.count);\n          this.playSuccessSound();\n          if (this.onPushupCount) this.onPushupCount(jjState.count);\n          if (this.onFormFeedback) this.onFormFeedback({ message: `Jumping Jack ${jjState.count}`, type: 'success', timestamp: now });\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating jumping jacks counter:', error);\n    }\n  }\n\n  // Update side plank counter (time-based like regular plank)\n  updateSidePlankCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const spConfig = window.MediaPipeConfig?.SIDEPLANK_CONFIG || {};\n\n      // Get key landmarks for side plank\n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n      const nose = landmarks[config.NOSE || 0];\n      const leftEar = landmarks[config.LEFT_EAR || 7];\n      const rightEar = landmarks[config.RIGHT_EAR || 8];\n\n      // Check visibility of key landmarks\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      \n      // Determine which side is the support side (left or right)\n      // We'll check both sides and use the one with better visibility\n      const leftSideVisible = vis(leftShoulder) && vis(leftElbow) && vis(leftHip) && vis(leftKnee) && vis(leftAnkle);\n      const rightSideVisible = vis(rightShoulder) && vis(rightElbow) && vis(rightHip) && vis(rightKnee) && vis(rightAnkle);\n      \n      if (!leftSideVisible && !rightSideVisible) {\n        return; // Not enough landmarks visible\n      }\n\n      // Use the side with better visibility\n      const isLeftSide = leftSideVisible && (!rightSideVisible || leftSideVisible);\n      const supportShoulder = isLeftSide ? leftShoulder : rightShoulder;\n      const supportElbow = isLeftSide ? leftElbow : rightElbow;\n      const supportWrist = isLeftSide ? leftWrist : rightWrist;\n      const supportHip = isLeftSide ? leftHip : rightHip;\n      const supportKnee = isLeftSide ? leftKnee : rightKnee;\n      const supportAnkle = isLeftSide ? leftAnkle : rightAnkle;\n      const supportEar = isLeftSide ? leftEar : rightEar;\n\n      // Calculate key angles for side plank validation\n      \n      // 1. Shoulder Support Angle (shoulder-elbow-wrist) - should be ~90¬∞\n      const shoulderSupportAngle = this.calculateAngle(supportShoulder, supportElbow, supportWrist);\n      const SHOULDER_ANGLE_MIN = spConfig.SHOULDER_ANGLE_MIN || 80;\n      const SHOULDER_ANGLE_MAX = spConfig.SHOULDER_ANGLE_MAX || 100;\n      const shoulderAngleGood = shoulderSupportAngle >= SHOULDER_ANGLE_MIN && shoulderSupportAngle <= SHOULDER_ANGLE_MAX;\n\n      // 2. Torso-Hip Line (shoulder-hip-ankle) - should be ~180¬∞ (straight line)\n      const torsoHipAngle = this.calculateAngle(supportShoulder, supportHip, supportAnkle);\n      const TORSO_ANGLE_MIN = spConfig.TORSO_ANGLE_MIN || 160;\n      const TORSO_ANGLE_MAX = spConfig.TORSO_ANGLE_MAX || 200;\n      const torsoAngleGood = torsoHipAngle >= TORSO_ANGLE_MIN && torsoHipAngle <= TORSO_ANGLE_MAX;\n\n      // 3. Check for hip sag (hip drops below shoulder-ankle line)\n      const shoulderAnkleMidY = (supportShoulder.y + supportAnkle.y) / 2;\n      const hipSagThreshold = spConfig.HIP_SAG_THRESHOLD || 0.05; // normalized units\n      const hipSag = supportHip.y > (shoulderAnkleMidY + hipSagThreshold);\n      \n      // 4. Check for hip hike (hip rises above shoulder-ankle line)\n      const hipHikeThreshold = spConfig.HIP_HIKE_THRESHOLD || 0.05; // normalized units\n      const hipHike = supportHip.y < (shoulderAnkleMidY - hipHikeThreshold);\n\n      // 5. Check elbow alignment (elbow should be under shoulder)\n      const elbowAlignmentThreshold = spConfig.ELBOW_ALIGNMENT_THRESHOLD || 0.08; // normalized units\n      const elbowAligned = Math.abs(supportElbow.x - supportShoulder.x) < elbowAlignmentThreshold;\n\n      // 6. Check feet stacking (ankles should be close together)\n      const feetStackingThreshold = spConfig.FEET_STACKING_THRESHOLD || 0.1; // normalized units\n      const feetStacked = Math.abs(leftAnkle.x - rightAnkle.x) < feetStackingThreshold;\n\n      // 7. Head-neck alignment (ear-shoulder-hip should be ~180¬∞)\n      let headNeckGood = true;\n      if (supportEar && vis(supportEar)) {\n        const headNeckAngle = this.calculateAngle(supportEar, supportShoulder, supportHip);\n        const HEAD_NECK_ANGLE_MIN = spConfig.HEAD_NECK_ANGLE_MIN || 160;\n        const HEAD_NECK_ANGLE_MAX = spConfig.HEAD_NECK_ANGLE_MAX || 200;\n        headNeckGood = headNeckAngle >= HEAD_NECK_ANGLE_MIN && headNeckAngle <= HEAD_NECK_ANGLE_MAX;\n      }\n\n      // Overall posture assessment\n      const isGoodPosture = shoulderAngleGood && \n                           torsoAngleGood && \n                           !hipSag && \n                           !hipHike && \n                           elbowAligned && \n                           feetStacked && \n                           headNeckGood;\n\n      // Debug logging\n      console.log('üîç Side Plank Debug:', {\n        side: isLeftSide ? 'Left' : 'Right',\n        shoulderAngle: Math.round(shoulderSupportAngle),\n        torsoAngle: Math.round(torsoHipAngle),\n        hipSag,\n        hipHike,\n        elbowAligned,\n        feetStacked,\n        headNeckGood,\n        isGoodPosture,\n        postureStatus: this.postureStatus\n      });\n\n      // Update posture status with smoothing\n      if (isGoodPosture) {\n        this._postureGoodCount = (this._postureGoodCount || 0) + 1;\n        this._postureBadCount = 0;\n      } else {\n        this._postureBadCount = (this._postureBadCount || 0) + 1;\n        this._postureGoodCount = 0;\n      }\n\n      const POSTURE_GOOD_FRAMES = spConfig.POSTURE_GOOD_FRAMES || 3;\n      const POSTURE_BAD_FRAMES = spConfig.POSTURE_BAD_FRAMES || 4;\n\n      let smoothedStatus = this.postureStatus;\n      if (this._postureGoodCount >= POSTURE_GOOD_FRAMES) {\n        smoothedStatus = 'correct';\n      } else if (this._postureBadCount >= POSTURE_BAD_FRAMES) {\n        smoothedStatus = 'incorrect';\n      }\n\n      if (smoothedStatus !== this.postureStatus) {\n        this.postureStatus = smoothedStatus;\n        if (this.onPostureChange) this.onPostureChange(this.postureStatus, landmarks);\n      }\n\n      // Handle timing for side plank (similar to regular plank)\n      if (this.postureStatus === 'correct') {\n        const now = Date.now();\n        if (!this.timerRunning) {\n          this.startCorrectTimestampMs = now;\n          this.timerRunning = true;\n        }\n        const totalMs = this.accumulatedCorrectMs + (now - (this.startCorrectTimestampMs || now));\n        const seconds = Math.floor(totalMs / 1000);\n        if (this.onTimeUpdate) this.onTimeUpdate(seconds);\n      } else {\n        // Stop timer when posture is incorrect\n        if (this.timerRunning) {\n          this.accumulatedCorrectMs += Date.now() - this.startCorrectTimestampMs;\n          this.timerRunning = false;\n          this.startCorrectTimestampMs = 0;\n          if (this.onTimeUpdate) {\n            this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n          }\n        }\n      }\n\n      // Provide form feedback for common mistakes\n      if (!isGoodPosture && this.onFormFeedback) {\n        const currentTime = Date.now();\n        const cooldown = spConfig.WARNING_COOLDOWN || 2000;\n        \n        if (currentTime - this.lastWarningTime > cooldown) {\n          let feedbackMessage = '';\n          if (hipSag) {\n            feedbackMessage = 'Hip sagging - lift your hips up!';\n          } else if (hipHike) {\n            feedbackMessage = 'Hip too high - lower your hips!';\n          } else if (!elbowAligned) {\n            feedbackMessage = 'Keep elbow under shoulder!';\n          } else if (!feetStacked) {\n            feedbackMessage = 'Stack your feet together!';\n          } else if (!shoulderAngleGood) {\n            feedbackMessage = 'Adjust your arm position!';\n          } else if (!torsoAngleGood) {\n            feedbackMessage = 'Keep your body straight!';\n          }\n\n          if (feedbackMessage) {\n            this.onFormFeedback({\n              message: feedbackMessage,\n              type: 'warning',\n              timestamp: currentTime\n            });\n            this.lastWarningTime = currentTime;\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating side plank counter:', error);\n    }\n  }\n\n  // Play warning sound\n  playWarningSound() {\n    try {\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      \n      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\n      oscillator.type = 'sine';\n      \n      gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);\n      \n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + 0.5);\n    } catch (error) {\n      console.error('Error playing warning sound:', error);\n    }\n  }\n\n  // Play success sound (pop.wav)\n  playSuccessSound() {\n    try {\n      const audio = new Audio('/assets/sounds/pop.wav');\n      audio.volume = 0.5; // Set volume to 50%\n      audio.play().catch(error => {\n        console.error('Error playing success sound:', error);\n      });\n    } catch (error) {\n      console.error('Error creating success sound:', error);\n    }\n  }\n\n  // Draw pose landmarks on canvas\n  drawPoseOverlay(canvasCtx, results, canvasWidth, canvasHeight) {\n    // Only log occasionally to avoid spam\n    if (Math.random() < 0.05) {\n      console.log('üé® Drawing pose overlay with', results.poseLandmarks?.length || 0, 'landmarks');\n    }\n\n    if (!results.poseLandmarks || !canvasCtx) {\n      return;\n    }\n\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    // Draw landmarks\n    const landmarks = results.poseLandmarks;\n    let drawnLandmarks = 0;\n    \n    landmarks.forEach((landmark, index) => {\n      if (landmark.visibility && landmark.visibility > 0.5) {\n        const x = landmark.x * canvasWidth;\n        const y = landmark.y * canvasHeight;\n        \n        canvasCtx.beginPath();\n        canvasCtx.arc(x, y, 6, 0, 2 * Math.PI); // Bigger circles\n        canvasCtx.fillStyle = landmark.visibility > 0.7 ? '#10B981' : '#F59E0B';\n        canvasCtx.fill();\n        canvasCtx.strokeStyle = '#FFFFFF';\n        canvasCtx.lineWidth = 2;\n        canvasCtx.stroke();\n        drawnLandmarks++;\n      }\n    });\n\n    // Only log occasionally\n    if (Math.random() < 0.1) {\n      console.log('‚ú® Drew', drawnLandmarks, 'landmarks');\n    }\n\n    // Always use basic connections (more reliable)\n    this.drawBasicConnections(canvasCtx, landmarks, canvasWidth, canvasHeight);\n\n    canvasCtx.restore();\n  }\n\n  // Draw basic pose connections\n  drawBasicConnections(canvasCtx, landmarks, canvasWidth, canvasHeight) {\n    const connections = [\n      [11, 12], // shoulders\n      [11, 13], // left shoulder to elbow\n      [13, 15], // left elbow to wrist\n      [12, 14], // right shoulder to elbow\n      [14, 16], // right elbow to wrist\n      [11, 23], // left shoulder to hip\n      [12, 24], // right shoulder to hip\n      [23, 24], // hips\n      [23, 25], // left hip to knee\n      [25, 27], // left knee to ankle\n      [24, 26], // right hip to knee\n      [26, 28]  // right knee to ankle\n    ];\n\n    let drawnConnections = 0;\n    connections.forEach(([startIdx, endIdx]) => {\n      const startPoint = landmarks[startIdx];\n      const endPoint = landmarks[endIdx];\n\n      if (startPoint && endPoint && \n          startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n        canvasCtx.beginPath();\n        canvasCtx.moveTo(startPoint.x * canvasWidth, startPoint.y * canvasHeight);\n        canvasCtx.lineTo(endPoint.x * canvasWidth, endPoint.y * canvasHeight);\n        canvasCtx.strokeStyle = '#3B82F6';\n        canvasCtx.lineWidth = 3; // Thicker lines\n        canvasCtx.stroke();\n        drawnConnections++;\n      }\n    });\n    \n    // Only log occasionally\n    if (Math.random() < 0.02) {\n      console.log('‚úÖ Drawing completed!', drawnConnections, 'connections');\n    }\n  }\n\n  // Reset counter\n  resetCounter() {\n    // Reset only the counters/state for the currently selected exercise\n    const mode = this.exerciseMode;\n    if (this.perModeState && this.perModeState[mode]) {\n      this.perModeState[mode].count = 0;\n      this.perModeState[mode].state = 'up';\n      // reset mode-specific extras\n      if (mode === 'situps') {\n        this.perModeState[mode]._lastTorsoAngle = null;\n        this.perModeState[mode]._situpState = 'down';\n        this.perModeState[mode]._lastSitupTime = 0;\n      }\n      if (mode === 'burpees') {\n        this.perModeState[mode]._burpeeState = 'ready';\n      }\n      if (mode === 'jumpingjacks') {\n        this.perModeState[mode]._lastRepAt = 0;\n      }\n      if (mode === 'sideplank') {\n        // Reset side plank state\n        this.perModeState[mode].state = 'neutral';\n        this.perModeState[mode].count = 0;\n      }\n      if (mode === 'plank') {\n        // Reset plank stability/timing helpers\n        this.perModeState[mode]._stableCount = 0;\n        this.perModeState[mode]._lastHipY = null;\n        this.perModeState[mode]._lastShoulderY = null;\n        this.perModeState[mode]._lastAnkleY = null;\n        this.perModeState[mode]._lastTimestamp = 0;\n      }\n    }\n    this.postureStatus = 'unknown';\n    // Reset plank timing\n    this.accumulatedCorrectMs = 0;\n    this.timerRunning = false;\n    this.startCorrectTimestampMs = 0;\n  }\n\n  // Get current stats\n  getStats() {\n    const mode = this.exerciseMode;\n    const stateObj = this.perModeState && this.perModeState[mode] ? this.perModeState[mode] : { count: 0, state: 'up' };\n    return {\n      count: stateObj.count || 0,\n      state: stateObj.state || 'up',\n      posture: this.postureStatus,\n      timeSec: Math.floor((this.accumulatedCorrectMs + (this.timerRunning ? (Date.now() - this.startCorrectTimestampMs) : 0)) / 1000)\n    };\n  }\n\n  // Get latest pose results for drawing\n  getLastResults() {\n    return this.lastResults;\n  }\n\n  // Set callback functions\n  setCallbacks({ onPushupCount, onPostureChange, onFormFeedback, onTimeUpdate }) {\n    this.onPushupCount = onPushupCount;\n    this.onPostureChange = onPostureChange;\n    this.onFormFeedback = onFormFeedback;\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Cleanup\n  cleanup() {\n    if (this.pose) {\n      this.pose.close();\n      this.pose = null;\n    }\n    this.isInitialized = false;\n  }\n}\n\nexport default PoseDetectionUtils;\n"],"names":["PoseDetectionUtils","constructor","this","pose","isInitialized","perModeState","state","count","_lastTorsoAngle","_situpState","_lastSitupTime","_stableCount","_lastHipY","_lastShoulderY","_lastAnkleY","_lastTimestamp","postureStatus","lastWarningTime","videoDimensionsLogged","exerciseMode","accumulatedCorrectMs","timerRunning","startCorrectTimestampMs","onPushupCount","onPostureChange","onFormFeedback","onTimeUpdate","setExerciseMode","mode","normalized","String","toLowerCase","includes","initialize","_a","window","Pose","attempts","Promise","resolve","setTimeout","locateFile","file","config","MediaPipeConfig","POSE_CONFIG","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","setOptions","onResults","bind","error","processFrame","videoElement","Math","random","videoWidth","videoHeight","maxWidth","maxHeight","send","image","message","results","_b","_c","_d","_e","_f","_g","_h","_i","lastResults","poseLandmarks","Date","now","floor","landmarks","isPostureCorrectInstant","checkBackAlignment","_postureGoodCount","_postureBadCount","POSTURE_GOOD_FRAMES","SQUAT_CONFIG","POSTURE_BAD_FRAMES","smoothedStatus","cfg","POSE_LANDMARKS","leftHip","LEFT_HIP","rightHip","RIGHT_HIP","leftKnee","LEFT_KNEE","rightKnee","RIGHT_KNEE","hipCenter","x","y","kneeCenter","currentTime","cooldown","PLANK_CONFIG","WARNING_COOLDOWN","playWarningSound","type","timestamp","isPlankStrictAndStable","totalMs","seconds","updateSquatCounter","updateLungesCounter","updateBurpeesCounter","updateSitUpsCounter","updateHighKneesCounter","updateJumpingJacksCounter","updateSidePlankCounter","updatePushupCounter","calculateAngle","point1","point2","point3","radians","atan2","angle","abs","PI","nowMs","LEFT_SHOULDER","RIGHT_SHOULDER","LEFT_ANKLE","RIGHT_ANKLE","leftShoulder","rightShoulder","leftAnkle","rightAnkle","vis","p","visibility","leftSideOk","rightSideOk","horizontalOk","MIN_SIDE_ANGLE","shoulderCenter","dx","dy","orientDeg","HORIZ_MAX","HORIZ_MAX_DEG","hipY","shoulderY","ankleY","maxDeltaPerSec","MAX_DELTA_PER_SEC","dt","max","hipDelta","shoulderDelta","ankleDelta","motionTooHigh","REQUIRED_STABLE_FRAMES","stableEnough","hipAnkleDy","MIN_HIP_ANKLE_DY","e","isPushupStartPose","shoulderCenterY","hipCenterY","torsoDy","PUSHUP_CONFIG","START_TORSO_DY","isSquatStartPose","kneeY","START_HIP_KNEE_GAP","angDeg","MIN_VERT","STANDING_TORSO_MIN_DEG","MAX_VERT","STANDING_TORSO_MAX_DEG","ankleCenter","targetPoint","v1","v2","isGoodPosture","leftSideVisible","rightSideVisible","shoulder","hip","ankle","sideAngle","leftKneeAngle","rightKneeAngle","kneeMin","KNEE_MIN_DEG","cosSim","mag1","hypot","mag2","absCos","min","straightEnough","STRAIGHT_ABS_COS_MIN","horizMax","nearHorizontal","kneeOk","scfg","hipAngleLeft","hipAngle","hipAngleMin","HIP_ANGLE_MIN","collapseThreshold","HIP_ANGLE_COLLAPSE","torsoTiltDeg","tiltMax","TORSO_TILT_MAX","hipBelowKnee","collapseTiltMin","COLLAPSE_TILT_MIN","SIDE_ABS_COS_MIN","HORIZ_TORSO_MAX_DEG","pushupConfig","leftElbow","LEFT_ELBOW","leftWrist","LEFT_WRIST","rightElbow","RIGHT_ELBOW","rightWrist","RIGHT_WRIST","leftElbowAngle","avgElbowAngle","avgShoulderY","downThreshold","ELBOW_ANGLE_DOWN","upThreshold","ELBOW_ANGLE_UP","shoulderHeightThreshold","SHOULDER_HEIGHT_DOWN","shoulderHipDy","isLikelyStanding","TORSO_VERTICAL_DY","STANDING_DY_MIN","pstate","_baselineShoulderY","shoulderDrop","shoulderDropThreshold","SHOULDER_DROP_THRESHOLD","pushupPosition","standingPosition","_inPositionCount","START_STABLE_FRAMES","_isInStartPose","MIN_REP_MS","_lastRepAt","playSuccessSound","head","NOSE","HORIZONTAL_THRESHOLD","headHipDy","isHorizontalLikePushup","leftFoot","rightFoot","HANDS_ON_GROUND_THRESHOLD","handsOnGround","avgWristY","knee","kneeAngleLeft","leftKneeY","rightKneeY","kneeHeightDiff","legsStable","hipAboveKnee","stateObj","LUNGES_CONFIG","leftKneeBent","frontKnee","frontKneeAngle","backKneeAngle","rightKneeBent","altFrontKneeAngle","altBackKneeAngle","KNEE_Y_DIFF_THRESHOLD","BACK_KNEE_ANGLE_THRESHOLD","FRONT_KNEE_ANGLE_THRESHOLD","HIP_FORWARD_THRESHOLD","oneLegForward","backKneeBent","frontKneeBent","frontHip","frontAnkle","hipForwardLean","lungePosition1","altBackKneeBent","altFrontKneeBent","altFrontHip","altFrontAnkle","altHipForwardLean","lungePosition","lstate","midShoulder","midHip","midKnee","torsoAngle","SITUP_CONFIG","SITUP_ANGLE_DOWN","ANGLE_DOWN","SITUP_ANGLE_UP","ANGLE_UP","nose","leftIndex","LEFT_INDEX","rightIndex","RIGHT_INDEX","headY","leftHandY","rightHandY","handsAboveHead","_burpeeState","bstate","KNEE_HIP_THRESHOLD","isLeftKneeHigh","isRightKneeHigh","isDoingHighKnees","hk","_highKneesState","_startTime","_lastUpdateTime","elapsedSeconds","jjConfig","JUMPINGJACKS_CONFIG","leftShoulderAbduction","rightShoulderAbduction","leftHipAbduction","rightHipAbduction","SHOULDER_ABDUCTION_DOWN","SHOULDER_ABDUCTION_UP","HIP_ABDUCTION_DOWN","HIP_ABDUCTION_UP","UP_FRAMES","DOWN_FRAMES","ANKLE_SCALE","MIN_UP_MS","jjState","_upCount","_downCount","_baselineAnkleDist","_upSince","_history","HISTORY_MAX","avgShoulderAbduction","avgHipAbduction","ankleDistance","hipDistance","shoulderSpan","torsoHeight","normalizedAnkleDistance","normalizedHipDistance","wristAboveShoulderNorm","push","sa","ha","nad","nhd","wan","length","shift","smooth","forEach","h","hf","smoothedShoulderAbduction","smoothedHipAbduction","smoothedNormalizedAnkleDistance","smoothedNormalizedHipDistance","smoothedWristAboveShoulder","shouldersAngleUp","hipsAngleApart","wristsAboveHeadSm","anklesWiderSm","isUpPeak","armsLow","anklesNarrow","isDownPose","_debugCounter","_ignoreUntil","_lastStateChange","upDuration","spConfig","SIDEPLANK_CONFIG","leftEar","LEFT_EAR","rightEar","RIGHT_EAR","isLeftSide","supportShoulder","supportElbow","supportWrist","supportHip","supportAnkle","supportEar","shoulderSupportAngle","SHOULDER_ANGLE_MIN","SHOULDER_ANGLE_MAX","shoulderAngleGood","torsoHipAngle","TORSO_ANGLE_MIN","TORSO_ANGLE_MAX","torsoAngleGood","shoulderAnkleMidY","hipSagThreshold","HIP_SAG_THRESHOLD","hipSag","hipHikeThreshold","HIP_HIKE_THRESHOLD","hipHike","elbowAlignmentThreshold","ELBOW_ALIGNMENT_THRESHOLD","elbowAligned","feetStackingThreshold","FEET_STACKING_THRESHOLD","feetStacked","headNeckGood","headNeckAngle","HEAD_NECK_ANGLE_MIN","HEAD_NECK_ANGLE_MAX","feedbackMessage","audioContext","AudioContext","webkitAudioContext","oscillator","createOscillator","gainNode","createGain","connect","destination","frequency","setValueAtTime","gain","linearRampToValueAtTime","exponentialRampToValueAtTime","start","stop","audio","Audio","volume","play","catch","drawPoseOverlay","canvasCtx","canvasWidth","canvasHeight","save","clearRect","landmark","index","beginPath","arc","fillStyle","fill","strokeStyle","lineWidth","stroke","drawBasicConnections","restore","startIdx","endIdx","startPoint","endPoint","moveTo","lineTo","resetCounter","getStats","posture","timeSec","getLastResults","setCallbacks","cleanup","close"],"mappings":"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"}